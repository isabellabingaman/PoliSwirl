- Class: meta
  Course: PoliSwirl
  Lesson: Wrangling
  Author: Isabella Bingaman
  Type: Standard
  Organization: American University
  Version: 2.4.4

- Class: text
  Output: In this lesson, you'll learn how to wrangle political data to work for you. 

- Class: text
  Output: First and foremost, it's not always easy to import your data. Often you'll find political data in an unfamiliar source format. The 'foreign' package can help with that. 
  
  
- Class: text
  Output: The 'foreign' package contains functions to read data from SPSS, Minitab, STATA and other varied formats. We'll use an SPSS file for an example, though each format takes on similar arguments.
  

- Class: text
  Output: The function read.spss() will effectively read your data into the console. The first argument read.spss() takes should always be "the name of the dataframe in quotation marks" 

- Class: text
  Output: Additionally, if you wish the result to be displayed in a data frame, make sure to use the argument to.data.frame = TRUE and vice versa for the opposite.  

- Class: text
  Output: If you do NOT want the variables with value labels to be converted into R factors with corresponding levels, you should set the use.value.labels argument to FALSE. 



- Class: mult_question
  Output: Which is the correct command necessary to read the SPSS data named "survey.sav" into a data frame called SPSSData?
  AnswerChoices: SPSSData <- read.spss("survey.sav", to.data.frame = TRUE);read.spss(SPSSData, "survey.sav");SPSSData(read.spss, "survey.sav", to.data.frame = TRUE)
  CorrectAnswer: SPSSData <- read.spss("survey.sav", to.data.frame = TRUE)
  AnswerTests: omnitest(correctVal='SPSSData <- read.spss("survey.sav", to.data.frame = TRUE)')
  Hint: Remember which aspects of the command line are functions and which are arguments.

- Class: text
  Output: Once you've read the data, it's important to make sure your variables are correctly named so that you can reference them quickly and easily.

- Class: text
  Output: Your variables (columns) should be named consistently in either PascalCase, snakecase, or with under_scores. PascalCase, as it appears, capitalizes the first letter of each word only. snakecase has all letters in lowercase. under_scores separate each unique word! 


- Class: cmd_question
  Output: Assign the number 10 to the variable named with the phrase "thebiggestnumber" in PascalCase
  CorrectAnswer: TheBiggestNumber <- 10
  AnswerTests: omnitest(correctExpr='TheBiggestNumber <- 10')
  Hint: Remember, PascalCase uses a new uppercase at the start of each word. 

- Class: text
  Output: It is important to maintain the names of all of your columns in the same format to efficiently reference your variables. Whether it be with PascalCase, snakecase, or using under_scores, each column should be formatted exactly the same. 
  
- Class: text
  Output: The rename() function from the dplyr package helps us significantly. It is most efficient to use the pipe with rename to specify the data frame you're working in. The syntax of the arguments specify the new and existing column names, where NewName = ExistingName and multiple name changes are separated by a comma. For the purposes of wrangling data, its most useful to re-assign this data set back to the original to start using the cleaned version right away.  

- Class: text
  Output: For example, to rename the "caseid" column in the ANES dataset to "CaseID", the following function would be appropriate --    ANES <- ANES %>% rename(CaseID = caseid)

- Class: cmd_question
  Output: Rename the "weight" and "follow" columns within ANES data with leading Uppercase Letters and re-assign it back to the original ANES dataset. 
  CorrectAnswer: ANES <- ANES %>% rename(Weight = weight, Follow = follow)
  AnswerTests: omnitest(correctExpr='ANES <- ANES %>% rename(Weight = weight, Follow = follow)')
  Hint: The correct new column names are "Weight" and "Follow".Start by assigning the dataset back to ANES, then make sure you're using the pipe to identify the data you'll be renaming. Remember to separate the two arguments with a comma.

- Class: text
  Output: It is also important that the variables have brief yet meaningful labels. It is all too common that those who collect political data don't record it in a way that is efficient for data analysis. Luckily, the recode() function makes this process relatively quick and painless.

- Class: text
  Output: The recode() function behaves similarly to the rename() function, but instead of utilizing the pipe, uses the $ to specify exactly which data are being recoded. To start, identify the column you wish to recode in the format of DataFrame$Column and assign that object to a recode(). After identifying the correct column again in the first argument of the function, "Old Labels" are set equal to = "New Labels" and separated by, commas. 
  
- Class: text
  Output: For example, to recode the flag variable within the PolityIV dataset, the correct syntax would be     PolityIV$flag <- recode(PolityIV$flag, "0" = "NA", "1" = "Positive", "2" = "Negative") 



- Class: cmd_question
  Output: Run the command PolityIV$flag <- recode(PolityIV$flag, "0" = "None", "1" = "Positive", "2" = "Negative") in the console to recode the flag variable.
  CorrectAnswer: PolityIV$flag <- recode(PolityIV$flag, "0" = "None", "1" = "Positive", "2" = "Negative")
  AnswerTests: omnitest(correctExpr='PolityIV$flag <- recode(PolityIV$flag, "0" = "None", "1" = "Positive", "2" = "Negative")')
  Hint: Enter the exact command-line code. 


- Class: cmd_question
  Output: Use the unique(PolityIV$flag) function to view the new, unique labels we have created for the flag variable.
  CorrectAnswer: unique(PolityIV$flag)
  AnswerTests: omnitest(correctExpr='unique(PolityIV$flag)')
  Hint: Enter the exact command-line code. 


- Class: text
  Output: Sometimes variables are a little harder to transform, such as date/time variables. The lubridate package is extremely helpful in coercing date/time variables.

- Class: text
  Output: In order to make date/time variables work for us, they should be in a standard format. When formatting, R uses a specific syntax to refer to each type of format. 
  
  
- Class: figure
  Output: At the most basic level, these symbols represent date objects in each potential format. When coercing variables into dates, the format argument will help R to read the format of our current date and/or interpret the desired output.  
  Figure: symbol.R
  FigureType: new

- Class: text
  Output: The first argument in the as.Date() function takes the data of characters to be converted. The proceeding argument clarifies the format.   

- Class: text
  Output: For example, if the characters I wanted to reformat into dates look like "04/25/1998", the format I would specify is "%m/%d/%Y" 


- Class: video
  Output: If you'd like more detail on how lubridate interprets date-times, visit their very helpful cheat sheet. 
  VideoLink: https://rawgit.com/rstudio/cheatsheets/master/lubridate.pdf


- Class: mult_question
  Output: If a column in our data frame named Dates is formatted like "April 25 1998", which would correctly conver these characters to dates?
  AnswerChoices: df$Dates <- as.Date(df$Dates, format = "%B %d %Y");df$Dates <- as.Date(df$Dates, format = "%b-%d-%Y");df$Dates <- as.Date(df$Dates, format = "%B %Y %d")
  CorrectAnswer: df$Dates <- as.Date(df$Dates, format = "%B %d %Y")
  AnswerTests: omnitest(correctVal='df$Dates <- as.Date(df$Dates, format = "%B %d %Y")')
  Hint: Make sure you're using the same separator as the original string. Make sure you're paying attention to capitalization and order.

- Class: figure
  Output: Sometimes, our date values (year, month, day) are spread throughout columns, such as shown below in the nycflights13 data. It is most efficient to consolidate the variables and gather them into one date column.
  Figure: flights.R
  FigureType: new

- Class: text
  Output: We can use the make_date() function to execute this. It's best practice to first rename columns with meaningful labels (so, for example, the column that contains the "year" variable should be named "year"). To make the new "date" column, we can utilize the mutate() function, setting the new "date" column equal to the make_date() function that specifies which columns to pull the variables from, separated by commas.  

- Class: text_question
  Output: Use the mutate() function to make a new column named "date" within the dataframe flights using the 3 columns year, month, and day.
  CorrectAnswer: mutate(flights, date = make_date(year, month, day))
  AnswerTests: omnitest(correctExpr='mutate(flights, date = make_date(year, month, day))')
  Hint: Use the make_date() function within the mutate() function. The arguments in the make_date() function are your column names, separated by commas.

- Class: text
  Output: Another important aspect in wrangling political data to work for you is ensuring there are no extra symbols that could complicate your analysis, such as leading dollar signs or commas in large numbers that stop you from conducting numeric analysis. The gsub() function along with the as.numeric() function remedy these issues. 

- Class: text
  Output: The gsub() function essentially subsitutes a string of text with other text. After we have successfully substituted out the text we no longer want from the string, as.numeric will coerce the string variable back into a numeric.

- Class: video
  Output: By using the gsub() function to subsitute the unwanted string with blank "" we can effectively delete it. But we must remember that when we identify metacharacters such as the dollar sign, we must utilize the \escape to ensure we are correctly identifying the characters we wish to substitute. For a refresher on metacharacters and regular expressions, you can enlist in the RegEx swirl course!
  VideoLink: https://swirlstats.com/scn/regular_expressions.html

- Class: figure
  Output: So, given data such as numbers,
  Figure: numbersdata.R
  FigureType: new


- Class: figure
  Output: We would use the command numbersdata$numbers <- as.numeric(gsub(",","",numbersdata$numbers) to replace all commas with nothing, effectively deleting them. Notice that the gsub() function takes the data argument after the pattern argument. 
  Figure: numbersagain.R
  FigureType: new


- Class: text
  Output: Last but not least, it is extremely important to acknowledge factor levels within political data. Often, variables such as political party and religion have more meaning than their simple categories and share a relationship between the other responses as levels. 

- Class: text
  Output: Using simple base R functions, we can add value labels to our data in order to structure it in levels. There are two functions, factor() which can be used with nominal data, and ordered() which can be used with ordinal data. They both take on the same arguments. 

- Class: text
  Output: The first argument factor() and ordered() take is the dataframe$column of interest, followed by the levels = argument, where you identify how the levels are coded within the dataframe. After this, the labels = argument, which identifies the cooresponding levels in order. 

- Class: text
  Output: For example, given a dataset that includes the variable displaying `feeling_thermometer` scores coded with 1, 3 and 5 to represent Low, Medium, and High readings. If we want to assign this ordinal data to the score levels 1=Low, 2=Medium,3=High, we would use the ordinal() function. 

- Class: mult_question
  Output: Which is the correct command line for assigning these levels?
  AnswerChoices: mydata$feeling_thermometer <- ordered(mydata$feeling_thermometer,levels = c(1,3, 5),labels = c("Low", "Medium", "High"));mydata$feeling_thermometer <- ordered(mydata$feeling_thermometer,labels = c(1,3, 5),levels = c("Low", "Medium", "High"));mydata$feeling_thermometer <- ordered(labels = c("Low", "Medium", "High"))
  CorrectAnswer: mydata$feeling_thermometer <- ordered(mydata$feeling_thermometer,levels = c(1,3, 5),labels = c("Low", "Medium", "High"))
  AnswerTests: omnitest(correctVal='mydata$feeling_thermometer <- ordered(mydata$feeling_thermometer,levels = c(1,3, 5),labels = c("Low", "Medium", "High"))')
  Hint: Pay attention to detail.

- Class: text
  Output: After your data is wrangled and cleaned, you're ready to model it and test it out. Move on to the next sections to learn more!

