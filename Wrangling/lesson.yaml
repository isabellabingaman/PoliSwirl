- Class: meta
  Course: PoliSwirl
  Lesson: Wrangling
  Author: Isabella Bingaman
  Type: Standard
  Organization: American University
  Version: 2.4.4

- Class: text
  Output: In this lesson, you'll learn how to wrangle political data to work for you. 

- Class: text
  Output: First and foremost, it's not always easy to import your data. Often you'll find political data in an unfamiliar source format. The 'foreign' package can help with that. 
  
  
- Class: text
  Output: The 'foreign' package contains functions to read data from SPSS, Minitab, STATA and other varied formats. We'll use an SPSS file for an example, though each format takes on similar arguments.
  

- Class: text
  Output: The function read.spss() will effectively read your data into the console. The first argument read.spss() takes should always be "the name of the dataframe in quotation marks" 

- Class: text
  Output: Additionally, if you wish the result to be displayed in a data frame, make sure to use the argument to.data.frame = TRUE and vice versa for the opposite.  

- Class: text
  Output: If you do NOT want the variables with value labels to be converted into R factors with corresponding levels, you should set the use.value.labels argument to FALSE. 



- Class: mult_question
  Output: Which is the correct command necessary to read the SPSS data named "survey.sav" into a data frame called SPSSData?
  AnswerChoices: SPSSData <- read.spss("survey.sav", to.data.frame = TRUE);read.spss(SPSSData, "survey.sav");SPSSData(read.spss, "survey.sav", to.data.frame = TRUE)
  CorrectAnswer: SPSSData <- read.spss("survey.sav", to.data.frame = TRUE)
  AnswerTests: omnitest(correctVal='SPSSData <- read.spss("survey.sav", to.data.frame = TRUE)')
  Hint: Remember which aspects of the command line are functions and which are arguments.

- Class: text
  Output: Once you've read the data, it's important to make sure your variables are correctly named so that you can reference them quickly and easily.

- Class: text
  Output: Your variables (columns) should be named consistently in either PascalCase, snakecase, or with under_scores. PascalCase, as it appears, capitalizes the first letter of each word only. snakecase has all letters in lowercase. under_scores separate each unique word! 


- Class: cmd_question
  Output: Assign the number 10 to the variable named with the phrase "thebiggestnumber" in PascalCase
  CorrectAnswer: TheBiggestNumber <- 10
  AnswerTests: omnitest(correctExpr='TheBiggestNumber <- 10')
  Hint: Remember, PascalCase uses a new uppercase at the start of each word. 

- Class: text
  Output: It is important to maintain the names of all of your columns in the same format to efficiently reference your variables. Whether it be with PascalCase, snakecase, or using under_scores, each column should be formatted exactly the same. 
  
- Class: text
  Output: The rename() function from the dplyr package helps us significantly. It is most efficient to use the pipe with rename to specify the data frame you're working in. The syntax of the arguments specify the new and existing column names, where NewName = ExistingName and multiple name changes are separated by a comma. For the purposes of wrangling data, its most useful to re-assign this data set back to the original to start using the cleaned version right away.  

- Class: text
  Output: For example, to rename the "caseid" column in the ANES dataset to "CaseID", the following function would be appropriate --    ANES <- ANES %>% rename(CaseID = caseid)

- Class: cmd_question
  Output: Rename the "weight" and "follow" columns within ANES data with leading Uppercase Letters and re-assign it back to the original ANES dataset. 
  CorrectAnswer: ANES <- ANES %>% rename(Weight = weight, Follow = follow)
  AnswerTests: omnitest(correctExpr='ANES <- ANES %>% rename(Weight = weight, Follow = follow)')
  Hint: The correct new column names are "Weight" and "Follow".Start by assigning the dataset back to ANES, then make sure you're using the pipe to identify the data you'll be renaming. Remember to separate the two arguments with a comma.

- Class: text
  Output: It is also important that the variables have brief yet meaningful labels. It is all too common that those who collect political data don't record it in a way that is efficient for data analysis. Luckily, the recode() function makes this process relatively quick and painless.

- Class: text
  Output: The recode() function behaves similarly to the rename() function, but instead of utilizing the pipe, uses the $ to specify exactly which data are being recoded. To start, identify the column you wish to recode in the format of DataFrame$Column and assign that object to a recode(). After identifying the correct column again in the first argument of the function, "Old Labels" are set equal to = "New Labels" and separated by, commas. 
  
- Class: text
  Output: For example, to recode the flag variable within the PolityIV dataset, the correct syntax would be     PolityIV$flag <- recode(PolityIV$flag, "0" = "NA", "1" = "Positive", "2" = "Negative") 



- Class: cmd_question
  Output: Run the command PolityIV$flag <- recode(PolityIV$flag, "0" = "None", "1" = "Positive", "2" = "Negative") in the console to recode the flag variable.
  CorrectAnswer: PolityIV$flag <- recode(PolityIV$flag, "0" = "None", "1" = "Positive", "2" = "Negative")
  AnswerTests: omnitest(correctExpr='PolityIV$flag <- recode(PolityIV$flag, "0" = "None", "1" = "Positive", "2" = "Negative")')
  Hint: Enter the exact command-line code. 


- Class: cmd_question
  Output: Use the unique(PolityIV$flag) function to view the new, unique labels we have created for the flag variable.
  CorrectAnswer: unique(PolityIV$flag)
  AnswerTests: omnitest(correctExpr='unique(PolityIV$flag)')
  Hint: Enter the exact command-line code. 


- Class: text
  Output: Sometimes variables are a little harder to transform, such as date/time variables. The lubridate package is extremely helpful in coercing date/time variables.

- Class: text
  Output: In order to make date/time variables work for us, they should be in a standard format. When formatting, R uses a specific syntax to refer to each type of format. 
  
  
- Class: figure
  Output: At the most basic level, these symbols represent date objects in each potential format. When coercing variables into dates, the format argument will help R to read the format of our current date and/or interpret the desired output.  
  Figure: symbol.R
  FigureType: new

- Class: text
  Output: The first argument in the as.Date() function takes the data of characters to be converted. The proceeding argument clarifies the format.   

- Class: text
  Output: For example, if the characters I wanted to reformat into dates look like "04/25/1998", the format I would specify is "%m/%d/%Y" 



- Class: video
  Output: If you'd like more detail on how lubridate interprets date-times, visit their very helpful cheat sheet. 
  VideoLink: https://rawgit.com/rstudio/cheatsheets/master/lubridate.pdf



- Class: text_question
  Output: In "quotes", write the correct date format for the character string "2007-06-22"
  CorrectAnswer: "%Y-%m-%d"
  AnswerTests: omnitest(correctExpr='"%Y-%m-%d"')
  Hint: Make sure you're using the same separator as the original string. Make sure you're paying attention to capitalization and order. Make sure you put your answer in quotation marks. 
